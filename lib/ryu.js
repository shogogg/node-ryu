// Generated by CoffeeScript 1.3.3
var Chain, ChainError, Context,
  __slice = [].slice;

exports.chain = function(chainName) {
  if (chainName == null) {
    chainName = 'nameless';
  }
  return {
    build: function() {
      var callback, chain, step, steps, _i, _len;
      steps = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (steps.length === 0) {
        throw new ChainError('Cannot create empty chain.');
      }
      for (_i = 0, _len = steps.length; _i < _len; _i++) {
        step = steps[_i];
        if (typeof step !== 'function') {
          throw new TypeError("" + (typeof step) + " is not a function.");
        }
      }
      callback = steps.pop();
      chain = new Chain(chainName, steps, callback);
      return function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return chain.start(args);
      };
    }
  };
};

Context = (function() {

  Context.prototype.name = null;

  Context.prototype.data = null;

  Context.prototype.step = null;

  Context.prototype._chain = null;

  Context.prototype._state = null;

  function Context(chain, state) {
    this.name = chain.name;
    this.data = {};
    this.step = 0;
    this._chain = chain;
    this._state = state;
  }

  Context.prototype.next = function() {
    var args, state;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    state = this._checkState();
    if (state.asyncCalled) {
      throw new ChainError("async() already called at chain `" + this._chain.name + "`.");
    }
    state.nextCalled = true;
    state.args = args;
  };

  Context.prototype.last = function() {
    var args, state;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    state = this._checkState();
    if (state.asyncCalled) {
      throw new ChainError("async() already called at chain `" + this._chain.name + "`.");
    }
    state.lastCalled = true;
    state.args = args;
  };

  Context.prototype.async = function(options) {
    var index, state,
      _this = this;
    state = this._checkState();
    state.asyncCalled = true;
    index = state.asyncCount++;
    options = this._createAsyncOptions(options);
    return function() {
      var args, err;
      err = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (err) {
        return _this._chain.onFailure(_this, err);
      }
      if (!options.useArray) {
        args = args[options.index];
      }
      state.args[index] = args;
      if (++state.asyncCompleteCount >= state.asyncCount) {
        _this._chain.wait(_this, state);
      }
    };
  };

  Context.prototype._checkState = function() {
    var state;
    state = this._state;
    if (state.nextCalled) {
      throw new ChainError("next() already called at chain `" + this._chain.name + "`.");
    }
    if (state.lastCalled) {
      throw new ChainError("last() already called at chain `" + this._chain.name + "`.");
    }
    return state;
  };

  Context.prototype._createAsyncOptions = function(options) {
    var _ref;
    if (options === null || options === void 0) {
      return {
        index: 0
      };
    }
    if (typeof options === 'number') {
      return {
        index: options
      };
    }
    if (options.useArray) {
      return {
        useArray: true
      };
    }
    return {
      index: parseInt((_ref = options.index) != null ? _ref : 0)
    };
  };

  return Context;

})();

Chain = (function() {

  Chain.prototype.name = null;

  Chain.prototype._steps = null;

  Chain.prototype._callback = null;

  Chain.prototype._context = null;

  function Chain(name, steps, callback) {
    this.name = name;
    this._steps = steps;
    this._callback = callback;
  }

  Chain.prototype.start = function(args) {
    var context, state;
    state = {};
    context = new Context(this, state);
    return this.runWithArgs(context, state, args);
  };

  Chain.prototype.run = function(context, state) {
    this.runWithArgs(context, state, state.args);
  };

  Chain.prototype.runWithArgs = function(context, state, args) {
    var _this = this;
    process.nextTick(function() {
      var steps;
      _this.resetState(state);
      steps = _this._steps;
      if (context.step === steps.length) {
        return _this.onSuccess(context, args);
      }
      try {
        steps[context.step].apply(context, args);
        context.step++;
        state.stepCompleted = true;
        if (state.lastCalled) {
          _this.onSuccess(context, state.args);
        } else if (state.nextCalled) {
          _this.run(context, state);
        } else if (!state.asyncCalled) {
          throw new ChainError('Cannot chain functions without call `next` or `last` or `async`.');
        }
      } catch (err) {
        _this.onFailure(context, err);
      }
    });
  };

  Chain.prototype.resetState = function(state) {
    state.args = [];
    state.lastCalled = false;
    state.nextCalled = false;
    state.asyncCalled = false;
    state.asyncCount = 0;
    state.asyncCompleteCount = 0;
    state.stepCompleted = false;
    return state;
  };

  Chain.prototype.wait = function(context, state) {
    var _this = this;
    if (!state.stepCompleted) {
      process.nextTick(function() {
        return _this.wait(context, state);
      });
    } else {
      this.run(context, state);
    }
  };

  Chain.prototype.onSuccess = function(context, args) {
    if (Array.isArray(args) && args.length > 0) {
      args.unshift(void 0);
    } else {
      args = void 0;
    }
    this.onComplete(context, this._callback, args);
  };

  Chain.prototype.onFailure = function(context, err) {
    this.onComplete(context, this._callback, [err]);
  };

  Chain.prototype.onComplete = function(context, callback, args) {
    process.nextTick(function() {
      return callback.apply(context, args);
    });
  };

  return Chain;

})();

ChainError = exports.ChainError = function(msg, cause) {
  Error.call(this, msg);
  if (msg !== void 0) {
    this.message = msg;
  }
  if (cause !== void 0) {
    return this.cause = cause;
  }
};

ChainError.prototype = (function() {
  var Inheritor;
  Inheritor = function() {};
  Inheritor.prototype = Error.prototype;
  return new Inheritor();
})();

ChainError.prototype.constructor = ChainError;

ChainError.prototype.name = 'ChainError';

ChainError.prototype.message = '';
